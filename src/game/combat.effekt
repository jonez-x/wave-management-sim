module src/game/combat

import src/types
import src/utils/math
import src/utils/lists
import src/effects

/**
 * Apply damage to a minion.
 * @param minion - The minion to damage
 * @param damage - Amount of damage to deal
 * @return Updated minion
 */
def damageMinion(minion: Minion, damage: Double): Minion = {
  val newHp = minion.currentHp - damage
  if (newHp <= 0.0) {
    Minion(
      minion.id,
      minion.team,
      minion.minionType,
      minion.position,
      0.0,
      minion.stats,
      minion.targetId,
      minion.lastAttackTime,
      false
    )
  } else {
    Minion(
      minion.id,
      minion.team,
      minion.minionType,
      minion.position,
      newHp,
      minion.stats,
      minion.targetId,
      minion.lastAttackTime,
      minion.isAlive
    )
  }
}

/**
 * Apply damage to a turret.
 * @param turret - The turret to damage
 * @param damage - Amount of damage to deal
 * @return Updated turret
 */
def damageTurret(turret: Turret, damage: Double): Turret = {
  val newHp = turret.currentHp - damage
  if (newHp <= 0.0) {
    Turret(
      turret.id,
      turret.team,
      turret.position,
      0.0,
      turret.targetId,
      turret.lastAttackTime,
      false
    )
  } else {
    Turret(
      turret.id,
      turret.team,
      turret.position,
      newHp,
      turret.targetId,
      turret.lastAttackTime,
      turret.isAlive
    )
  }
}

/**
 * Check if minion just attacked (used to apply damage).
 * @param minion - The minion to check
 * @param currentTime - Current simulation time
 * @param deltaTime - Time delta
 * @return True if minion just attacked
 */
def justAttacked(minion: Minion, currentTime: Double, deltaTime: Double): Bool = {
  val timeSinceAttack = currentTime - minion.lastAttackTime
  timeSinceAttack >= 0.0 && timeSinceAttack < deltaTime * 2.0
}

/**
 * Find minion by ID.
 * @param minions - List of minions
 * @param id - ID to find
 * @return Option containing the minion if found
 */
def findMinionById(minions: List[Minion], id: Int): Option[Minion] = {
  listFind(minions) { m => m.id == id }
}

/**
 * Check if minion is in attack range of position.
 * @param minion - The attacking minion
 * @param targetPos - Target position
 * @return True if in range
 */
def isInRange(minion: Minion, targetPos: Vec2): Bool = {
  distance(minion.position, targetPos) <= minion.stats.attackRange
}

/**
 * Check if turret is in attack range of minion.
 * @param turretPos - Turret position
 * @param minionPos - Minion position
 * @return True if in range
 */
def turretInRange(turretPos: Vec2, minionPos: Vec2): Bool = {
  distance(turretPos, minionPos) <= TURRET_STATS.attackRange
}

/**
 * Apply damage from a single attacker to target minion.
 * @param minions - List of minions
 * @param attackerId - ID of attacking minion
 * @param damage - Damage to deal
 * @param currentTime - Current time
 * @param deltaTime - Time delta
 * @return Updated list of minions
 */
def applyMinionDamage(minions: List[Minion], attackerId: Int, 
                       damage: Double, currentTime: Double, deltaTime: Double): List[Minion] = {
  val attackerOpt = findMinionById(minions, attackerId)
  attackerOpt match {
    case None() => minions
    case Some(attacker) =>
      if (not(attacker.isAlive)) {
        minions
      } else {
        if (justAttacked(attacker, currentTime, deltaTime)) {
          val targetId = attacker.targetId
          if (targetId >= 0) {
            listMap(minions) { m =>
              if (m.id == targetId && m.isAlive && isInRange(attacker, m.position)) {
                damageMinion(m, damage)
              } else {
                m
              }
            }
          } else {
            minions
          }
        } else {
          minions
        }
      }
  }
}

/**
 * Update projectiles (move and hit).
 * @param projectiles - List of projectiles
 * @param minions - List of minions
 * @param deltaTime - Time delta
 * @return Tuple of (remaining projectiles, updated minions)
 */
def updateProjectiles(projectiles: List[Projectile], minions: List[Minion], 
                      deltaTime: Double): (List[Projectile], List[Minion]) = {
                      
  var nextProjectiles = Nil[Projectile]()
  var currentMinions = minions
  
  listForEach(projectiles) { p =>
    val targetOpt = findMinionById(currentMinions, p.targetId)
    
    val targetPos = targetOpt match {
      case Some(m) => m.position
      case None() => p.targetPos
    }
    
    val dir = normalize(sub(targetPos, p.position))
    val moveDist = p.speed * deltaTime
    val distToTarget = distance(p.position, targetPos)
    
    if (distToTarget <= moveDist) {
      targetOpt match {
        case Some(m) =>
           currentMinions = listMap(currentMinions) { min =>
             if (min.id == m.id) damageMinion(min, p.damage)
             else min
           }
        case None() => ()
      }
    } else {
      val newPos = add(p.position, scale(dir, moveDist))
      nextProjectiles = Cons(Projectile(p.id, newPos, p.targetId, p.damage, p.speed, p.isCaster, p.isTurret, targetPos), nextProjectiles)
    }
  }
  
  (nextProjectiles, currentMinions)
}

/**
 * Process all minion-to-minion combat (spawns projectiles or deals damage).
 * @param minions - List of minions
 * @param projectiles - Current projectiles
 * @param nextId - Next entity ID
 * @param currentTime - Current time
 * @param deltaTime - Time delta
 * @return Tuple of (updated minions, new projectiles, next ID)
 */
def processAllMinionCombat(minions: List[Minion], projectiles: List[Projectile], nextId: Int,
                           currentTime: Double, deltaTime: Double): (List[Minion], List[Projectile], Int) = {

  var updatedMinions = minions
  var newProjectiles = projectiles
  var currentNextId = nextId
  
  listForEach(minions) { attacker =>
    if (attacker.isAlive && justAttacked(attacker, currentTime, deltaTime) && attacker.targetId >= 0) {
       val targetOpt = findMinionById(minions, attacker.targetId) // Check original for validity
       targetOpt match {
         case Some(target) =>
           if (target.isAlive && isInRange(attacker, target.position)) {
              attacker.minionType match {
                case Melee() =>
                  updatedMinions = listMap(updatedMinions) { m =>
                    if (m.id == target.id) damageMinion(m, attacker.stats.attackDamage)
                    else m
                  }
                case Caster() =>
                  val projId = currentNextId
                  currentNextId = currentNextId + 1
                  val proj = Projectile(
                    projId, attacker.position, target.id, attacker.stats.attackDamage, 
                    450.0, true, false, target.position
                  ) 
                  newProjectiles = Cons(proj, newProjectiles)
                  
                case Cannon() =>
                  val projId = currentNextId
                  currentNextId = currentNextId + 1
                  val proj = Projectile(
                    projId, attacker.position, target.id, attacker.stats.attackDamage,
                    350.0, false, false, target.position
                  )
                  newProjectiles = Cons(proj, newProjectiles)
              }
           }
         case None() => ()
       }
    }
  }
  
  (updatedMinions, newProjectiles, currentNextId)
}

/**
 * Process minion attacks on turrets.
 * @param minions - List of minions
 * @param blueTurret - Blue team turret
 * @param redTurret - Red team turret
 * @param currentTime - Current time
 * @param deltaTime - Time delta
 * @return Tuple of (updated blue turret, updated red turret)
 */
def processMinionTurretCombat(minions: List[Minion], blueTurret: Turret, redTurret: Turret,
                               currentTime: Double, deltaTime: Double): (Turret, Turret) = {
  def processTurretAttacks(attackers: List[Minion], blue: Turret, red: Turret): (Turret, Turret) = {
    attackers match {
      case Nil() => (blue, red)
      case Cons(attacker, rest) =>
        if (attacker.isAlive && justAttacked(attacker, currentTime, deltaTime) && attacker.targetId < 0) {
          attacker.team match {
            case Blue() =>
              if (red.isAlive && isInRange(attacker, red.position)) {
                val newRed = damageTurret(red, attacker.stats.attackDamage)
                processTurretAttacks(rest, blue, newRed)
              } else {
                processTurretAttacks(rest, blue, red)
              }
            case Red() =>
              if (blue.isAlive && isInRange(attacker, blue.position)) {
                val newBlue = damageTurret(blue, attacker.stats.attackDamage)
                processTurretAttacks(rest, newBlue, red)
              } else {
                processTurretAttacks(rest, blue, red)
              }
          }
        } else {
          processTurretAttacks(rest, blue, red)
        }
    }
  }
  processTurretAttacks(minions, blueTurret, redTurret)
}

/**
 * Find first enemy minion in turret range.
 * @param turret - The turret
 * @param minions - List of minions
 * @return Option containing first enemy in range
 */
def findTurretTarget(turret: Turret, minions: List[Minion]): Option[Minion] = {
  listFind(minions) { m =>
    if (not(m.isAlive)) {
      false
    } else {
      val isEnemy = turret.team match {
        case Blue() => m.team match {
          case Blue() => false
          case Red() => true
        }
        case Red() => m.team match {
          case Blue() => true
          case Red() => false
        }
      }
      isEnemy && turretInRange(turret.position, m.position)
    }
  }
}

/**
 * Check if turret can attack.
 * @param turret - The turret
 * @param currentTime - Current time
 * @return True if turret can attack
 */
def turretCanAttack(turret: Turret, currentTime: Double): Bool = {
  val cooldown = 1.0 / TURRET_STATS.attackSpeed
  currentTime - turret.lastAttackTime >= cooldown
}

/**
 * Process turret attacks on minions - spawns projectiles instead of instant damage.
 * @param minions - List of minions
 * @param blueTurret - Blue turret
 * @param redTurret - Red turret
 * @param projectiles - Current projectiles
 * @param nextId - Next entity ID
 * @param currentTime - Current time
 * @return Tuple of (updated blue turret, updated red turret, new projectiles, next ID)
 */
def processTurretCombat(minions: List[Minion], blueTurret: Turret, redTurret: Turret,
                         projectiles: List[Projectile], nextId: Int,
                         currentTime: Double): (Turret, Turret, List[Projectile], Int) = {
  var updatedBlue = blueTurret
  var updatedRed = redTurret
  var newProjectiles = projectiles
  var currentNextId = nextId
  
  if (blueTurret.isAlive && turretCanAttack(blueTurret, currentTime)) {
    val targetOpt = findTurretTarget(blueTurret, minions)
    targetOpt match {
      case None() => ()
      case Some(target) =>
        val projId = currentNextId
        currentNextId = currentNextId + 1
        val proj = Projectile(
          projId, blueTurret.position, target.id, TURRET_STATS.attackDamage,
          600.0, false, true, target.position
        )
        newProjectiles = Cons(proj, newProjectiles)
        
        updatedBlue = Turret(
          blueTurret.id,
          blueTurret.team,
          blueTurret.position,
          blueTurret.currentHp,
          target.id,
          currentTime,
          blueTurret.isAlive
        )
    }
  }
  
  if (redTurret.isAlive && turretCanAttack(redTurret, currentTime)) {
    val targetOpt = findTurretTarget(redTurret, minions)
    targetOpt match {
      case None() => ()
      case Some(target) =>
        val projId = currentNextId
        currentNextId = currentNextId + 1
        val proj = Projectile(
          projId, redTurret.position, target.id, TURRET_STATS.attackDamage,
          600.0, false, true, target.position
        )
        newProjectiles = Cons(proj, newProjectiles)
        
        updatedRed = Turret(
          redTurret.id,
          redTurret.team,
          redTurret.position,
          redTurret.currentHp,
          target.id,
          currentTime,
          redTurret.isAlive
        )
    }
  }
  
  (updatedBlue, updatedRed, newProjectiles, currentNextId)
}

/**
 * Main combat processing function.
 * @param minions - List of minions
 * @param blueTurret - Blue turret
 * @param redTurret - Red turret
 * @param projectiles - Current projectiles
 * @param nextId - Next entity ID
 * @param currentTime - Current time
 * @param deltaTime - Time delta
 * @return Tuple of (updated minions, blue turret, red turret, projectiles, next ID)
 */
def processCombat(minions: List[Minion], blueTurret: Turret, redTurret: Turret,
                  projectiles: List[Projectile], nextId: Int,
                  currentTime: Double, deltaTime: Double): (List[Minion], Turret, Turret, List[Projectile], Int) = {
                  
  val (activeProjectiles, afterProjMinions) = updateProjectiles(projectiles, minions, deltaTime)
  
  val (afterCombatMinions, allProjectiles, combatNextId) = processAllMinionCombat(
    afterProjMinions, activeProjectiles, nextId, currentTime, deltaTime
  )
  
  val turretResult = processMinionTurretCombat(afterCombatMinions, blueTurret, redTurret, currentTime, deltaTime)
  
  turretResult match {
    case (newBlue, newRed) =>
      val (finalBlue, finalRed, turretProjectiles, finalNextId) = processTurretCombat(
        afterCombatMinions, newBlue, newRed, allProjectiles, combatNextId, currentTime
      )
      (afterCombatMinions, finalBlue, finalRed, turretProjectiles, finalNextId)
  }
}
