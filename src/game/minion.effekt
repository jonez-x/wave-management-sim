module src/game/minion

import src/types
import src/utils/math
import src/utils/lists
import src/utils/game
import src/effects

/**
 * Find nearest enemy minion for targeting.
 * @param minion - The minion searching for a target
 * @param allMinions - List of all minions
 * @return ID of nearest enemy, or -1 if none found
 */
def findNearestEnemy(minion: Minion, allMinions: List[Minion]): Int = {
  def findNearest(enemies: List[Minion], nearestId: Int, nearestDist: Double): Int = {
    enemies match {
      case Nil() => nearestId
      case Cons(enemy, rest) =>
        if (enemy.isAlive) {
          if (isEnemy(minion.team, enemy.team)) {
            val dist = distance(minion.position, enemy.position)
            if (nearestId < 0 || dist < nearestDist) {
              findNearest(rest, enemy.id, dist)
            } else {
              findNearest(rest, nearestId, nearestDist)
            }
          } else {
            findNearest(rest, nearestId, nearestDist)
          }
        } else {
          findNearest(rest, nearestId, nearestDist)
        }
    }
  }
  findNearest(allMinions, -1, 999999.0)
}

/**
 * Check if minion can attack (cooldown expired).
 * @param minion - The minion to check
 * @param currentTime - Current simulation time
 * @return True if cooldown has expired
 */
def canAttack(minion: Minion, currentTime: Double): Bool = {
  val cooldown = 1.0 / minion.stats.attackSpeed
  currentTime - minion.lastAttackTime >= cooldown
}

/**
 * Check if target is in attack range.
 * @param minion - The attacking minion
 * @param targetPos - Position of the target
 * @return True if target is within attack range
 */
def isInAttackRange(minion: Minion, targetPos: Vec2): Bool = {
  distance(minion.position, targetPos) <= minion.stats.attackRange
}

/**
 * Calculate separation vector to avoid overlapping with other minions.
 * @param minion - The minion to calculate separation for
 * @param allMinions - List of all minions
 * @return Separation force vector
 */
def calculateSeparation(minion: Minion, allMinions: List[Minion]): Vec2 = {
  var separation = Vec2(0.0, 0.0)
  var count = 0
  
  val myRadius = getMinionRadius(minion.minionType)
  
  listForEach(allMinions) { other =>
    if (minion.id != other.id && other.isAlive) {
      val dist = distance(minion.position, other.position)
      val otherRadius = getMinionRadius(other.minionType)
      val safeDist = myRadius + otherRadius + 2.0
      
      if (dist < safeDist) {
        val pushDir = if (dist > 0.0) normalize(sub(minion.position, other.position)) else Vec2(1.0, 0.0)
        
        val overlap = safeDist - dist
        val forceMagnitude = overlap / (dist + 0.1) * 10.0
        
        var forceVec = scale(pushDir, forceMagnitude)
        
        val sideDir = if (modDouble(minion.id.toDouble, 2.0) == 0.0) Vec2(0.0 - pushDir.y, pushDir.x) else Vec2(pushDir.y, 0.0 - pushDir.x)
        
        val tangentForce = scale(sideDir, forceMagnitude * 0.5)
        
        forceVec = add(forceVec, tangentForce)
        
        separation = add(separation, forceVec)
        count = count + 1
      }
    }
  }
  
  if (count > 0) {
    scale(separation, 50.0)
  } else {
    Vec2(0.0, 0.0)
  }
}


val BOUNDARY_PADDING: Double = 8.0

/**
 * Clamp position to stay within lane boundaries with padding.
 * Uses soft padding to prevent minions from sticking to edges.
 * @param pos - Position to clamp
 * @return Position clamped to lane boundaries
 */
def clampToLaneBoundaries(pos: Vec2): Vec2 = {
  val clampedX = clamp(pos.x, LANE_START_X + BOUNDARY_PADDING, LANE_END_X - BOUNDARY_PADDING)
  val clampedY = clamp(pos.y, LANE_MIN_Y + BOUNDARY_PADDING, LANE_MAX_Y - BOUNDARY_PADDING)
  Vec2(clampedX, clampedY)
}

/**
 * Calculate a boundary repulsion force to push minions away from edges.
 * This prevents minions from getting stuck at boundaries.
 * @param pos - Current position
 * @return Repulsion force vector
 */
def calculateBoundaryRepulsion(pos: Vec2): Vec2 = {
  val repelDistance = 25.0  // Start pushing when this close to edge
  val repelStrength = 80.0  // How strong the push is
  
  var forceX = 0.0
  var forceY = 0.0
  
  val distToLeft = pos.x - LANE_START_X
  val distToRight = LANE_END_X - pos.x
  val distToTop = pos.y - LANE_MIN_Y
  val distToBottom = LANE_MAX_Y - pos.y
  
  if (distToLeft < repelDistance && distToLeft > 0.0) {
    forceX = repelStrength * (1.0 - distToLeft / repelDistance)
  }
  if (distToRight < repelDistance && distToRight > 0.0) {
    forceX = 0.0 - repelStrength * (1.0 - distToRight / repelDistance)
  }
  if (distToTop < repelDistance && distToTop > 0.0) {
    forceY = repelStrength * (1.0 - distToTop / repelDistance)
  }
  if (distToBottom < repelDistance && distToBottom > 0.0) {
    forceY = 0.0 - repelStrength * (1.0 - distToBottom / repelDistance)
  }
  
  Vec2(forceX, forceY)
}

/**
 * Move minion towards target position with separation, boundary repulsion and clamping.
 * @param minion - The minion to move
 * @param targetPos - Target position
 * @param deltaTime - Time delta
 * @param allMinions - All minions for collision avoidance
 * @return New position clamped to lane boundaries
 */
def moveTowards(minion: Minion, targetPos: Vec2, deltaTime: Double, allMinions: List[Minion]): Vec2 = {
  val dirToTarget = sub(targetPos, minion.position)
  val distToTarget = magnitude(dirToTarget)
  
  val seekVelocity = if (distToTarget > 0.0) {
    scale(normalize(dirToTarget), minion.stats.movementSpeed)
  } else {
    Vec2(0.0, 0.0)
  }
  
  val separationForce = calculateSeparation(minion, allMinions)
  
  val boundaryForce = calculateBoundaryRepulsion(minion.position)
  
  val combinedVelocity = add(add(seekVelocity, separationForce), boundaryForce)
  
  val movement = scale(combinedVelocity, deltaTime)
  val newPos = add(minion.position, movement)
  
  clampToLaneBoundaries(newPos)
}

/**
 * Simple pseudo-random generator.
 * @param seed - Seed value
 * @return Pseudo-random value between 0.0 and 1.0
 */
def pseudoRandom(seed: Int): Double = {
  val s = absDouble(modDouble(seed.toDouble * 12.9898 + 78.233, 43758.5453))
  modDouble(s, 1.0)
}

/**
 * Get the goal position for a minion when no enemies are present.
 * Goal is clamped to lane boundaries.
 * @param minion - The minion
 * @return Goal position within lane boundaries
 */
def getGoalPosition(minion: Minion): Vec2 = {
  val goalX = minion.team match {
    case Blue() => LANE_END_X
    case Red() => LANE_START_X
  }
  
  val spread = (pseudoRandom(minion.id) - 0.5) * 80.0
  val targetY = clamp(LANE_Y + spread, LANE_MIN_Y + 10.0, LANE_MAX_Y - 10.0)
  
  Vec2(goalX, targetY)
}

/**
 * Find a minion by ID.
 * @param minions - List of minions
 * @param id - ID to find
 * @return Option containing the minion if found
 */
def findMinionById(minions: List[Minion], id: Int): Option[Minion] = {
  listFind(minions) { m => m.id == id }
}

/**
 * Check if target minion is still valid (alive and enemy).
 * @param minion - The minion checking
 * @param targetId - ID of target to validate
 * @param allMinions - All minions
 * @return True if target is valid
 */
def isTargetValid(minion: Minion, targetId: Int, allMinions: List[Minion]): Bool = {
  val target = findMinionById(allMinions, targetId)
  target match {
    case None() => false
    case Some(t) =>
      t.isAlive && isEnemy(minion.team, t.team)
  }
}

def updateMinion(minion: Minion, allMinions: List[Minion], 
                 blueTurret: Turret, redTurret: Turret,
                 deltaTime: Double, currentTime: Double,
                 isTanking: Bool, tankPos: Vec2): Minion = {
  if (not(minion.isAlive)) {
    minion
  } else {
    val shouldTargetTank = isTanking &&
                           distance(minion.position, tankPos) <= TANK_AGGRO_RANGE
    val enemyTurretForTarget = minion.team match {
      case Blue() => redTurret
      case Red() => blueTurret
    }
    val turretInRange = enemyTurretForTarget.isAlive &&
                         isInAttackRange(minion, enemyTurretForTarget.position)

    val currentTarget = if (shouldTargetTank) {
      TANK_TARGET_ID
    } else if (turretInRange) {
      -1
    } else {
      if (minion.targetId == TANK_TARGET_ID) -1
      else if (minion.targetId >= 0 && isTargetValid(minion, minion.targetId, allMinions)) {
        findMinionById(allMinions, minion.targetId) match {
          case Some(target) =>
            if (isInAttackRange(minion, target.position)) {
               minion.targetId
            } else {
               findNearestEnemy(minion, allMinions)
            }
          case None() => findNearestEnemy(minion, allMinions)
        }
      } else {
        findNearestEnemy(minion, allMinions)
      }
    }

    if (currentTarget == TANK_TARGET_ID) {
       if (distance(minion.position, tankPos) <= TANK_ATTACK_RANGE) {
         if (canAttack(minion, currentTime)) {
           withAttack(minion, currentTarget, currentTime)
         } else {
           withTarget(minion, currentTarget)
         }
       } else {
         val newPos = moveTowards(minion, tankPos, deltaTime, allMinions)
         withTarget(withPosition(minion, newPos), currentTarget)
       }
    } else if (currentTarget >= 0) {
      val targetOpt = findMinionById(allMinions, currentTarget)
      targetOpt match {
        case None() =>
          withTarget(minion, -1)
        case Some(target) =>
          if (isInAttackRange(minion, target.position)) {
            if (canAttack(minion, currentTime)) {
              withAttack(minion, currentTarget, currentTime)
            } else {
              withTarget(minion, currentTarget)
            }
          } else {
            val newPos = moveTowards(minion, target.position, deltaTime, allMinions)
            withTarget(withPosition(minion, newPos), currentTarget)
          }
      }
    } else {
      val enemyTurret = minion.team match {
        case Blue() => redTurret
        case Red() => blueTurret
      }

      if (enemyTurret.isAlive) {
        if (isInAttackRange(minion, enemyTurret.position)) {
          if (canAttack(minion, currentTime)) {
            withAttack(minion, -1, currentTime)
          } else minion
        } else {
          val newPos = moveTowards(minion, enemyTurret.position, deltaTime, allMinions)
          withPosition(minion, newPos)
        }
      } else {
        val goal = getGoalPosition(minion)
        val newPos = moveTowards(minion, goal, deltaTime, allMinions)
        withPosition(minion, newPos)
      }
    }
  }
}

def updateAllMinions(minions: List[Minion], blueTurret: Turret, redTurret: Turret,
                     deltaTime: Double, currentTime: Double,
                     isTanking: Bool, tankPos: Vec2): List[Minion] = {
  listMap(minions) { m =>
    updateMinion(m, minions, blueTurret, redTurret, deltaTime, currentTime, isTanking, tankPos)
  }
}

/**
 * Returns the name of the minion type.
 * @param minionType - The type of minion
 * @return String representation like "Melee", "Caster", or "Cannon"
 */
def minionTypeName(minionType: MinionType): String =
  minionType match {
    case Melee() => "Melee"
    case Caster() => "Caster"
    case Cannon() => "Cannon"
  }

/**
 * Returns the base stats for a given minion type.
 * @param minionType - The type of minion
 * @return MinionStats record with base values
 */
def getMinionStats(minionType: MinionType): MinionStats =
  minionType match {
    case Melee() => MinionStats(
      maxHp = 477.0,
      attackDamage = 12.0 * DAMAGE_SCALE,
      attackSpeed = 1.25,
      attackRange = 110.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 21
    )
    case Caster() => MinionStats(
      maxHp = 296.0,
      attackDamage = 24.0 * DAMAGE_SCALE,
      attackSpeed = 0.667,
      attackRange = 550.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 14
    )
    case Cannon() => MinionStats(
      maxHp = 912.0,
      attackDamage = 41.0 * DAMAGE_SCALE,
      attackSpeed = 1.0,
      attackRange = 300.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 60
    )
  }

/**
 * Get minion radius for rendering.
 * @param minionType - The type of minion
 * @return The radius in pixels
 */
def getMinionRadius(minionType: MinionType): Double =
  minionType match {
    case Melee() => 12.0
    case Caster() => 8.0
    case Cannon() => 18.0
  }

/**
 * Apply scaling based on game time (90s cycles).
 * @param stats - Base minion stats
 * @param minionType - The type of minion
 * @param gameTime - Current game time in seconds
 * @return Scaled stats
 */
def applyScaling(stats: MinionStats, minionType: MinionType, gameTime: Double): MinionStats = {
  val cycleDuration = 90.0
  val cycles = floorDouble(maxDouble(0.0, gameTime) / cycleDuration)
  
  if (cycles <= 0.0) {
    stats
  } else {
    val (hpGrowth, adGrowth) = minionType match {
      case Melee() => (20.0, 0.5)
      case Caster() => (15.0, 2.0)
      case Cannon() => (50.0, 3.0)
    }
    
    val bonusHp = hpGrowth * cycles
    val bonusAd = adGrowth * cycles
    
    MinionStats(
      maxHp = stats.maxHp + bonusHp,
      attackDamage = stats.attackDamage + bonusAd,
      attackSpeed = stats.attackSpeed,
      attackRange = stats.attackRange,
      movementSpeed = stats.movementSpeed,
      goldValue = stats.goldValue
    )
  }
}

/**
 * Creates a new minion entity with scaled stats.
 * @param id - Unique identifier
 * @param team - Team the minion belongs to
 * @param minionType - Type of minion
 * @param spawnPos - Initial position
 * @param gameTime - Current game time for scaling
 * @return A new Minion record
 */
def createMinion(id: Int, team: Team, minionType: MinionType, spawnPos: Vec2, gameTime: Double): Minion = {
  val baseStats = getMinionStats(minionType)
  val scaledStats = applyScaling(baseStats, minionType, gameTime)

  Minion(
    id = id,
    team = team,
    minionType = minionType,
    position = spawnPos,
    currentHp = scaledStats.maxHp,
    stats = scaledStats,
    targetId = -1,
    lastAttackTime = 0.0,
    isAlive = true
  )
}

/**
 * Returns a copy of the minion with a new position.
 * @param m - The minion to copy
 * @param pos - The new position
 * @return Updated minion
 */
def withPosition(m: Minion, pos: Vec2): Minion =
  Minion(m.id, m.team, m.minionType, pos, m.currentHp, m.stats, m.targetId, m.lastAttackTime, m.isAlive)

/**
 * Returns a copy of the minion with a new target.
 * @param m - The minion to copy
 * @param targetId - The new target ID
 * @return Updated minion
 */
def withTarget(m: Minion, targetId: Int): Minion =
  Minion(m.id, m.team, m.minionType, m.position, m.currentHp, m.stats, targetId, m.lastAttackTime, m.isAlive)

/**
 * Returns a copy of the minion with a new target and attack timestamp.
 * @param m - The minion to copy
 * @param targetId - The new target ID
 * @param attackTime - The new last attack timestamp
 * @return Updated minion
 */
def withAttack(m: Minion, targetId: Int, attackTime: Double): Minion =
  Minion(m.id, m.team, m.minionType, m.position, m.currentHp, m.stats, targetId, attackTime, m.isAlive)

/**
 * Returns a copy of the minion with updated health.
 * @param m - The minion to copy
 * @param hp - The new health value
 * @return Updated minion
 */
def withHp(m: Minion, hp: Double): Minion =
  Minion(m.id, m.team, m.minionType, m.position, hp, m.stats, m.targetId, m.lastAttackTime, m.isAlive)

/**
 * Returns a dead copy of the minion with 0 HP.
 * @param m - The minion to kill
 * @return Dead minion
 */
def killMinion(m: Minion): Minion =
  Minion(m.id, m.team, m.minionType, m.position, 0.0, m.stats, m.targetId, m.lastAttackTime, false)

