module src/game/simulation

import src/types
import src/effects
import src/game/minion
import src/game/combat
import src/game/wave

// ============================================================
// Main Simulation Loop - Coordinates all game systems
// ============================================================

/**
 * Remove dead minions from the list.
 * @param minions - List of minions
 * @return List containing only alive minions
 */
def removeDeadMinions(minions: List[Minion]): List[Minion] = {
  listFilter(minions) { m => m.isAlive }
}

/**
 * Single simulation step - updates all game systems for one frame.
 * @param deltaTime - Time delta
 * @effect State - Modifies game state
 * @effect Time - Reads and advances simulation time
 */
def simulationStep(deltaTime: Double): Unit / {State, Time} = {
  val state = do getState()
  
  if (state.isPaused) {
    ()
  } else {
    val currentTime = do getCurrentTime()
    val speedMult = do getSpeedMultiplier()
    val adjustedDelta = deltaTime * speedMult
    
    do advanceTime(adjustedDelta)
    val newGameTime = state.gameTime + adjustedDelta
    
    val scheduleResult = checkAndScheduleWaves(
      newGameTime, 
      state.nextSpawnTime, 
      state.waveNumber,
      state.pendingSpawns
    )
    
    scheduleResult match {
      case (updatedPendingSpawns, newWaveNumber, newNextSpawnTime) =>
        // Detect if a wave was spawned (new scheduled)
        val waveSpawned = newWaveNumber > state.waveNumber
        val newWaveState = if (waveSpawned) {
          Neutral()  // Reset wave state when new wave spawns
        } else {
          state.waveState
        }
        
        val (afterSpawnMinions, remainingPending, newNextEntityId) = processPendingSpawns(
          updatedPendingSpawns,
          state.minions,
          state.nextEntityId,
          newGameTime
        )
        
        val movedMinions = updateAllMinions(
          afterSpawnMinions, 
          state.blueTurret, 
          state.redTurret,
          adjustedDelta, 
          currentTime,
          state.isPlayerTanking,
          state.tankPosition
        )
        
        val combatResult = processCombat(
          movedMinions, 
          state.blueTurret, 
          state.redTurret,
          state.projectiles,
          newNextEntityId,
          currentTime, 
          adjustedDelta
        )
        
        combatResult match {
          case (afterCombatMinions, newBlueTurret, newRedTurret, newProjectiles, finalEntityId) =>
            val aliveMinions = removeDeadMinions(afterCombatMinions)
            
            do setState(GameState(
              aliveMinions,
              newBlueTurret,
              newRedTurret,
              newGameTime,
              newWaveNumber,
              newNextSpawnTime,
              state.isPaused,
              state.speed,
              state.selectedTool,
              finalEntityId,
              newWaveState,
              state.isPlayerTanking,
              state.tankPosition,
              newProjectiles,
              remainingPending,
              state.visualEffects
            ))
        }
    }
  }
}

// Render the current game state
def renderGame(): Unit / {State, Render, Input} = {
  val state = do getState()
  val mousePos = do getMousePosition()
  
  do clear()
  
  do drawLane()
  
  do drawTurret(state.blueTurret)
  do drawTurret(state.redTurret)
  
  drawMinions(state.minions)
  
  do drawUI(state)
  
  do drawToolPreview(state.selectedTool, mousePos)
  
  drawAttackLines(state.minions, state.blueTurret, state.redTurret)
}

def drawMinions(minions: List[Minion]): Unit / Render = {
  minions match {
    case Nil() => ()
    case Cons(m, rest) =>
      if (m.isAlive) {
        do drawMinion(m)
      }
      drawMinions(rest)
  }
}

def drawAttackLines(minions: List[Minion], blueTurret: Turret, redTurret: Turret): Unit / Render = {
  if (blueTurret.isAlive && blueTurret.targetId >= 0) {
    val targetOpt = listFind(minions) { m => m.id == blueTurret.targetId }
    targetOpt match {
      case None() => ()
      case Some(target) =>
        if (target.isAlive) {
          do drawAttackLine(blueTurret.position, target.position, Blue())
        }
    }
  }
  
  if (redTurret.isAlive && redTurret.targetId >= 0) {
    val targetOpt = listFind(minions) { m => m.id == redTurret.targetId }
    targetOpt match {
      case None() => ()
      case Some(target) =>
        if (target.isAlive) {
          do drawAttackLine(redTurret.position, target.position, Red())
        }
    }
  }
}

def handleKeyboardInput(): Unit / {State, Input} = {
  val state = do getState()
  
  if (do isKeyDown(" ")) {
    setPaused(not(state.isPaused))
  }
  
  if (do isKeyDown("1")) {
    setSelectedTool(NoTool())
  }
  if (do isKeyDown("2")) {
    setSelectedTool(LastHitTool())
  }
  if (do isKeyDown("3")) {
    setSelectedTool(AoETool())
  }
  if (do isKeyDown("4")) {
    setSelectedTool(KillCastersTool())
  }
  if (do isKeyDown("5")) {
    setSelectedTool(FullClearTool())
  }
  if (do isKeyDown("6")) {
    setSelectedTool(TankTool())
  }
  
  if (do isKeyDown("+") || do isKeyDown("=")) {
    state.speed match {
      case Speed1x() => setSpeed(Speed2x())
      case Speed2x() => setSpeed(Speed4x())
      case Speed4x() => ()
    }
  }
  if (do isKeyDown("-") || do isKeyDown("_")) {
    state.speed match {
      case Speed1x() => ()
      case Speed2x() => setSpeed(Speed1x())
      case Speed4x() => setSpeed(Speed2x())
    }
  }
}

def gameLoopStep(deltaTime: Double): Unit / {State, Time, Render, Input} = {
  handleKeyboardInput()
  
  simulationStep(deltaTime)
  
  renderGame()
}
