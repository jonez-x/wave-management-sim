module src/game/simulation
import src/types
import src/effects
import src/game/minion
import src/game/combat
import src/game/wave
import src/utils/lists
import src/utils/math
import src/tools/dispatcher

/**
 * Remove dead minions from the list.
 * @param minions - List of minions
 * @return List containing only alive minions
 */
def removeDeadMinions(minions: List[Minion]): List[Minion] = {
  listFilter(minions) { m => m.isAlive }
}

/**
 * Single simulation step - updates all game systems for one frame.
 * @param deltaTime - Time delta
 * @effect State - Modifies game state
 * @effect Time - Reads and advances simulation time
 */
def simulationStep(deltaTime: Double): Unit / {State, Time} = {
  val state = do getState()
  
  if (state.isPaused) {
    ()
  } else {
    val currentTime = do getCurrentTime()
    val speedMult = do getSpeedMultiplier()
    val adjustedDelta = deltaTime * speedMult
    
    do advanceTime(adjustedDelta)
    val newGameTime = state.gameTime + adjustedDelta
    
    val scheduleResult = checkAndScheduleWaves(
      newGameTime, 
      state.nextSpawnTime, 
      state.waveNumber,
      state.pendingSpawns
    )
    
    scheduleResult match {
      case (updatedPendingSpawns, newWaveNumber, newNextSpawnTime) =>
        val (afterSpawnMinions, remainingPending, newNextEntityId) = processPendingSpawns(
          updatedPendingSpawns,
          state.minions,
          state.nextEntityId,
          newGameTime
        )
        
        val movedMinions = updateAllMinions(
          afterSpawnMinions, 
          state.blueTurret, 
          state.redTurret,
          adjustedDelta, 
          currentTime,
          state.isPlayerTanking,
          state.tankPosition
        )
        
        val combatResult = processCombat(
          movedMinions, 
          state.blueTurret, 
          state.redTurret,
          state.projectiles,
          newNextEntityId,
          currentTime, 
          adjustedDelta
        )
        
        combatResult match {
          case (afterCombatMinions, newBlueTurret, newRedTurret, newProjectiles, finalEntityId) =>
            val aliveMinions = removeDeadMinions(afterCombatMinions)
            
            val calculatedWaveState = calculateWaveState(
              aliveMinions,
              state.blueTurret.position.x,
              state.redTurret.position.x
            )
            
            val activeEffects = listFilter(state.visualEffects) { vfx =>
              (newGameTime - vfx.startTime) < vfx.duration
            }
            
            do setState(GameState(
              aliveMinions,
              newBlueTurret,
              newRedTurret,
              newGameTime,
              newWaveNumber,
              newNextSpawnTime,
              state.isPaused,
              state.speed,
              state.selectedTool,
              finalEntityId,
              calculatedWaveState,
              state.isPlayerTanking,
              state.tankPosition,
              newProjectiles,
              remainingPending,
              activeEffects
            ))
        }
    }
  }
}

/**
 * Renders the current game state to the screen.
 *
 * This function retrieves the current game state and mouse position,
 * clears the rendering context, and draws all game elements including
 * the lane and turrets.
 *
 * @effect State - Reads game state
 * @effect Render - Draws to the screen
 * @effect Input - Reads mouse position
 */
def renderGame(): Unit / {State, Render, Input} = {
  val state = do getState()
  val mousePos = do getMousePosition()
  
  do clear()
  
  do drawLane()
  
  do drawTurret(state.blueTurret)
  do drawTurret(state.redTurret)
  
  drawMinions(state.minions)
  
  listForEach(state.projectiles) { p =>
    do drawProjectile(p)
  }
  
  do drawTankIndicator(state.tankPosition, state.isPlayerTanking, state.gameTime)
  
  listForEach(state.visualEffects) { vfx =>
    do drawVisualEffect(vfx, state.gameTime)
  }

  do drawUI(state)
  
  do drawToolPreview(state.selectedTool, mousePos)
  
  drawAttackLines(state.minions, state.blueTurret, state.redTurret)
  drawMinionAttacks(state.minions, state.gameTime)
}

/**
 * Draws all alive minions.
 * @param minions - List of minions to draw
 * @effect Render - Draws to the screen
 */
def drawMinions(minions: List[Minion]): Unit / Render = {
  minions match {
    case Nil() => ()
    case Cons(m, rest) =>
      if (m.isAlive) {
        do drawMinion(m)
      }
      drawMinions(rest)
  }
}

/**
 * Draws attack lines from turrets to their current targets.
 * @param minions - List of minions to check for targets
 * @param blueTurret - The blue turret
 * @param redTurret - The red turret
 * @effect Render - Draws lines to the screen
 */
def drawAttackLines(minions: List[Minion], blueTurret: Turret, redTurret: Turret): Unit / Render = {
  if (blueTurret.isAlive && blueTurret.targetId >= 0) {
    val targetOpt = listFind(minions) { m => m.id == blueTurret.targetId }
    targetOpt match {
      case None() => ()
      case Some(target) =>
        if (target.isAlive) {
          do drawAttackLine(blueTurret.position, target.position, Blue())
        }
    }
  }
  
  if (redTurret.isAlive && redTurret.targetId >= 0) {
    val targetOpt = listFind(minions) { m => m.id == redTurret.targetId }
    targetOpt match {
      case None() => ()
      case Some(target) =>
        if (target.isAlive) {
          do drawAttackLine(redTurret.position, target.position, Red())
        }
    }
  }
}

/**
 * Draws attack lines for all melee minions that are currently attacking.
 * @param minions - List of all minions (used for iteration and target lookup)
 * @param gameTime - Current game time to check attack windows
 * @effect Render - Draws lines to the screen
 */
def drawMinionAttacks(minions: List[Minion], gameTime: Double): Unit / Render = {
  listForEach(minions) { m =>
    m.minionType match {
      case Melee() => 
        val timeSinceAttack = gameTime - m.lastAttackTime
        // Attack animation window: 0.0 to 0.15s after attack
        if (m.targetId >= 0 && timeSinceAttack < 0.15 && timeSinceAttack >= 0.0) {
           val targetOpt = listFind(minions) { t => t.id == m.targetId }
           targetOpt match {
             case Some(target) => 
               do drawMinionAttack(m, target)
             case None() => ()
           }
        }
      case _ => ()
    }
  }
}

/**
 * Handles keyboard input to control game state and tools.
 * @effect State - Reads and modifies game state (pause, speed, tools)
 * @effect Input - Checks for key presses
 */
def handleKeyboardInput(): Unit / {State, Input} = {
  val state = do getState()
  
  if (do wasKeyJustPressed(" ")) {
    setPaused(not(state.isPaused))
  }
  
  if (do wasKeyJustPressed("1")) {
    setSpeed(Speed1x())
  }
  if (do wasKeyJustPressed("2")) {
    setSpeed(Speed2x())
  }
  if (do wasKeyJustPressed("3")) {
    setSpeed(Speed4x())
  }
  
  if (do wasKeyJustPressed("q")) {
    setSelectedTool(LastHitTool())
  }
  if (do wasKeyJustPressed("w")) {
    setSelectedTool(AoETool())
  }
  if (do wasKeyJustPressed("e")) {
    setSelectedTool(KillCastersTool())
  }
  if (do wasKeyJustPressed("r")) {
    setSelectedTool(FullClearTool())
  }
  if (do wasKeyJustPressed("t")) {
    setSelectedTool(TankTool())
  }
  if (do wasKeyJustPressed("Escape")) {
    setSelectedTool(NoTool())
    setTankPosition(Vec2(0.0, 0.0), false)
  }
}

/**
 * Main game loop step calling input handling, simulation and rendering.
 * @param deltaTime - Time since last frame
 * @effect State - Modifies game state
 * @effect Time - Advances time
 * @effect Render - Draws the game
 * @effect Input - Handles input
 */
def gameLoopStep(deltaTime: Double): Unit / {State, Time, Render, Input} = {
  // Handle mouse clicks (Tool Usage)
  if (wasClicked()) {
    handleToolClick(getSelectedTool(), getMousePosition())
  }

  handleKeyboardInput()
  
  simulationStep(deltaTime)
  
  renderGame()
}
