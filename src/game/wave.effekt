module src/game/wave

import src/types
import src/effects
import src/handlers

// ============================================================
// Wave Spawning - Creates waves of minions for both teams
// ============================================================

// Check if this wave should have a cannon minion
def isCannonWave(waveNumber: Int): Bool = {
  waveNumber > 0 && modulo(waveNumber, CANNON_WAVE_INTERVAL) == 0
}

// Schedule a wave of minions for one team
// Returns a list of PendingSpawn
def scheduleTeamWave(team: Team, waveNumber: Int, StartTime: Double): List[PendingSpawn] = {
  var spawns: List[PendingSpawn] = Nil()
  var time = StartTime
  val interval = 0.8 // 0.8s ~ 1.0s delay for snake formation
  
  // 3 Melee minions
  spawns = Cons(PendingSpawn(team, Melee(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 0.0), spawns)
  time = time + interval
  
  // Cannon minion (if applicable)
  if (isCannonWave(waveNumber)) {
    spawns = Cons(PendingSpawn(team, Cannon(), time, 0.0), spawns)
    time = time + interval
  }
  
  // 3 Caster minions
  spawns = Cons(PendingSpawn(team, Caster(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 0.0), spawns)
  
  // List is reversed due to Cons, but order doesn't strictly matter for execution 
  // if we sort by time or just process all eligible. 
  // However, simpler to just reverse strict order if needed.
  // Actually, Cons adds to front. So Caster 3 is first.
  // We want Melee 1 first. Let's not worry about list order for now, 
  // the processing loop will check timestamps.
  spawns
}

// Schedule waves for both teams
def scheduleBothWaves(waveNumber: Int, currentTime: Double): List[PendingSpawn] = {
  val blueSpawns = scheduleTeamWave(Blue(), waveNumber, currentTime)
  val redSpawns = scheduleTeamWave(Red(), waveNumber, currentTime)
  listAppend(blueSpawns, redSpawns)
}

// Check if it's time to create a new wave schedule
def checkAndScheduleWaves(gameTime: Double, nextSpawnTime: Double, waveNumber: Int, 
                          currentPending: List[PendingSpawn]): (List[PendingSpawn], Int, Double) = {
  if (gameTime >= nextSpawnTime) {
    val newWaveNumber = waveNumber + 1
    val newSpawns = scheduleBothWaves(newWaveNumber, gameTime)
    val updatedPending = listAppend(currentPending, newSpawns)
    val newNextSpawnTime = nextSpawnTime + SPAWN_INTERVAL
    (updatedPending, newWaveNumber, newNextSpawnTime)
  } else {
    (currentPending, waveNumber, nextSpawnTime)
  }
}

// Process pending spawns - create minions if their time has come
def processPendingSpawns(pending: List[PendingSpawn], minions: List[Minion], 
                         nextId: Int, currentTime: Double): (List[Minion], List[PendingSpawn], Int) = {
                         
  var newMinions = minions
  var remainingPending = Nil[PendingSpawn]()
  var currentNextId = nextId
  
  listForEach(pending) { spawn =>
    if (currentTime >= spawn.spawnTime) {
      // It's time to spawn!
      val spawnX = spawn.team match {
        case Blue() => BLUE_SPAWN_X
        case Red() => RED_SPAWN_X
      }
      // Simple spawn at Nexus position
      // Minions will "walk in a line" because they spawn sequentially and move to same target
      val spawnPos = Vec2(spawnX, LANE_Y) 
      
      val minion = createMinion(currentNextId, spawn.team, spawn.minionType, spawnPos, currentTime)
      currentNextId = currentNextId + 1
      
      newMinions = Cons(minion, newMinions)
    } else {
      // Not time yet, keep in queue
      remainingPending = Cons(spawn, remainingPending)
    }
  }
  
  (newMinions, remainingPending, currentNextId)
}

// Get expected wave size
def getWaveSize(waveNumber: Int): Int = {
  val base = 6
  if (isCannonWave(waveNumber)) {
    base + 1
  } else {
    base
  }
}
