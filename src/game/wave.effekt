module src/game/wave

import src/types
import src/effects
import src/handlers

/**
 * Check if this wave should have a cannon minion.
 * @param waveNumber - Current wave number
 * @return True if cannon wave
 */
def isCannonWave(waveNumber: Int): Bool = {
  waveNumber > 0 && modulo(waveNumber, CANNON_WAVE_INTERVAL) == 0
}

/**
 * Schedule a wave of minions for one team.
 * @param team - Team to spawn for
 * @param waveNumber - Current wave number
 * @param StartTime - Time to start spawning
 * @return List of PendingSpawn
 */
def scheduleTeamWave(team: Team, waveNumber: Int, StartTime: Double): List[PendingSpawn] = {
  var spawns: List[PendingSpawn] = Nil()
  var time = StartTime
  val interval = 0.8
  
  // 3 Melee minions - minimale Streuung
  spawns = Cons(PendingSpawn(team, Melee(), time, -8.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 8.0), spawns)
  time = time + interval
  
  // Cannon minion (if applicable)
  if (isCannonWave(waveNumber)) {
    spawns = Cons(PendingSpawn(team, Cannon(), time, 0.0), spawns)
    time = time + interval
  }
  
  // Caster minions - minimale Streuung
  spawns = Cons(PendingSpawn(team, Caster(), time, -6.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 6.0), spawns)
  
  spawns
}

/**
 * Schedule waves for both teams.
 * @param waveNumber - Current wave number
 * @param currentTime - Current game time
 * @return Combined list of PendingSpawn for both teams
 */
def scheduleBothWaves(waveNumber: Int, currentTime: Double): List[PendingSpawn] = {
  val blueSpawns = scheduleTeamWave(Blue(), waveNumber, currentTime)
  val redSpawns = scheduleTeamWave(Red(), waveNumber, currentTime)
  listAppend(blueSpawns, redSpawns)
}

/**
 * Check if it's time to create a new wave schedule.
 * @param gameTime - Current game time
 * @param nextSpawnTime - Next scheduled spawn time
 * @param waveNumber - Current wave number
 * @param currentPending - Current pending spawns
 * @return Tuple of (updated pending, new wave number, next spawn time)
 */
def checkAndScheduleWaves(gameTime: Double, nextSpawnTime: Double, waveNumber: Int, 
                          currentPending: List[PendingSpawn]): (List[PendingSpawn], Int, Double) = {
  if (gameTime >= nextSpawnTime) {
    val newWaveNumber = waveNumber + 1
    val newSpawns = scheduleBothWaves(newWaveNumber, gameTime)
    val updatedPending = listAppend(currentPending, newSpawns)
    val newNextSpawnTime = nextSpawnTime + SPAWN_INTERVAL
    (updatedPending, newWaveNumber, newNextSpawnTime)
  } else {
    (currentPending, waveNumber, nextSpawnTime)
  }
}

/**
 * Process pending spawns - create minions if their time has come.
 * @param pending - List of pending spawns
 * @param minions - Current minions
 * @param nextId - Next entity ID
 * @param currentTime - Current game time
 * @return Tuple of (new minions, remaining pending, next ID)
 */
def processPendingSpawns(pending: List[PendingSpawn], minions: List[Minion], 
                         nextId: Int, currentTime: Double): (List[Minion], List[PendingSpawn], Int) = {
                         
  var newMinions = minions
  var remainingPending = Nil[PendingSpawn]()
  var currentNextId = nextId
  
  listForEach(pending) { spawn =>
    if (currentTime >= spawn.spawnTime) {
      val spawnX = spawn.team match {
        case Blue() => BLUE_SPAWN_X
        case Red() => RED_SPAWN_X
      }
      // Nutze laneOffset f√ºr vertikale Streuung beim Spawn
      val spawnY = clamp(LANE_Y + spawn.laneOffset, LANE_MIN_Y + 15.0, LANE_MAX_Y - 15.0)
      val spawnPos = Vec2(spawnX, spawnY)
      
      val minion = createMinion(currentNextId, spawn.team, spawn.minionType, spawnPos, currentTime)
      currentNextId = currentNextId + 1
      
      newMinions = Cons(minion, newMinions)
    } else {
      remainingPending = Cons(spawn, remainingPending)
    }
  }
  
  (newMinions, remainingPending, currentNextId)
}

/**
 * Get expected wave size.
 * @param waveNumber - Wave number to check
 * @return Number of minions in the wave
 */
def getWaveSize(waveNumber: Int): Int = {
  val base = 6
  if (isCannonWave(waveNumber)) {
    base + 1
  } else {
    base
  }
}
