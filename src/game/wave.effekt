module src/game/wave

import src/types
import src/utils/math
import src/utils/lists
import src/effects
import src/game/minion
import src/handlers
import src/helpers

/**
 * Check if this wave should have a cannon minion.
 * @param waveNumber - Current wave number
 * @return True if cannon wave
 */
def isCannonWave(waveNumber: Int): Bool = {
  waveNumber > 0 && modulo(waveNumber, CANNON_WAVE_INTERVAL) == 0
}

/**
 * Schedule a wave of minions for one team.
 * @param team - Team to spawn for
 * @param waveNumber - Current wave number
 * @param StartTime - Time to start spawning
 * @return List of PendingSpawn
 */
def scheduleTeamWave(team: Team, waveNumber: Int, StartTime: Double): List[PendingSpawn] = {
  var spawns: List[PendingSpawn] = Nil()
  var time = StartTime
  val interval = 0.8
  
  spawns = Cons(PendingSpawn(team, Melee(), time, -8.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Melee(), time, 8.0), spawns)
  time = time + interval
  
  if (isCannonWave(waveNumber)) {
    spawns = Cons(PendingSpawn(team, Cannon(), time, 0.0), spawns)
    time = time + interval
  }
  
  spawns = Cons(PendingSpawn(team, Caster(), time, -6.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 0.0), spawns)
  time = time + interval
  spawns = Cons(PendingSpawn(team, Caster(), time, 6.0), spawns)
  
  spawns
}

/**
 * Schedule waves for both teams.
 * @param waveNumber - Current wave number
 * @param currentTime - Current game time
 * @return Combined list of PendingSpawn for both teams
 */
def scheduleBothWaves(waveNumber: Int, currentTime: Double): List[PendingSpawn] = {
  val blueSpawns = scheduleTeamWave(Blue(), waveNumber, currentTime)
  val redSpawns = scheduleTeamWave(Red(), waveNumber, currentTime)
  listAppend(blueSpawns, redSpawns)
}

/**
 * Check if it's time to create a new wave schedule.
 * @param gameTime - Current game time
 * @param nextSpawnTime - Next scheduled spawn time
 * @param waveNumber - Current wave number
 * @param currentPending - Current pending spawns
 * @return Tuple of (updated pending, new wave number, next spawn time)
 */
def checkAndScheduleWaves(gameTime: Double, nextSpawnTime: Double, waveNumber: Int, 
                          currentPending: List[PendingSpawn]): (List[PendingSpawn], Int, Double) = {
  if (gameTime >= nextSpawnTime) {
    val newWaveNumber = waveNumber + 1
    val newSpawns = scheduleBothWaves(newWaveNumber, gameTime)
    val updatedPending = listAppend(currentPending, newSpawns)
    val newNextSpawnTime = nextSpawnTime + SPAWN_INTERVAL
    (updatedPending, newWaveNumber, newNextSpawnTime)
  } else {
    (currentPending, waveNumber, nextSpawnTime)
  }
}

/**
 * Process pending spawns - create minions if their time has come.
 * @param pending - List of pending spawns
 * @param minions - Current minions
 * @param nextId - Next entity ID
 * @param currentTime - Current game time
 * @return Tuple of (new minions, remaining pending, next ID)
 */
def processPendingSpawns(pending: List[PendingSpawn], minions: List[Minion], 
                         nextId: Int, currentTime: Double): (List[Minion], List[PendingSpawn], Int) = {
                         
  var newMinions = minions
  var remainingPending = Nil[PendingSpawn]()
  var currentNextId = nextId
  
  listForEach(pending) { spawn =>
    if (currentTime >= spawn.spawnTime) {
      val spawnX = spawn.team match {
        case Blue() => BLUE_SPAWN_X
        case Red() => RED_SPAWN_X
      }
      val spawnY = clamp(LANE_Y + spawn.laneOffset, LANE_MIN_Y + 15.0, LANE_MAX_Y - 15.0)
      val spawnPos = Vec2(spawnX, spawnY)
      
      val minion = createMinion(currentNextId, spawn.team, spawn.minionType, spawnPos, currentTime)
      currentNextId = currentNextId + 1
      
      newMinions = Cons(minion, newMinions)
    } else {
      remainingPending = Cons(spawn, remainingPending)
    }
  }
  
  (newMinions, remainingPending, currentNextId)
}

/**
 * Get expected wave size.
 * @param waveNumber - Wave number to check
 * @return Number of minions in the wave
 */
def getWaveSize(waveNumber: Int): Int = {
  val base = 6
  if (isCannonWave(waveNumber)) {
    base + 1
  } else {
    base
  }
}

/**
 * Calculate the average X position of all alive minions for a team.
 * @param minions - List of minions
 * @param team - The team to calculate for
 * @return Average X position, or -1.0 if no minions
 */
def getTeamAverageX(minions: List[Minion], team: Team): Double = {
  var sumX = 0.0
  var count = 0
  
  listForEach(minions) { m =>
    if (m.isAlive) {
      val isMatch = team match {
        case Blue() => m.team match {
          case Blue() => true
          case Red() => false
        }
        case Red() => m.team match {
          case Blue() => false
          case Red() => true
        }
      }
      if (isMatch) {
        sumX = sumX + m.position.x
        count = count + 1
      }
    }
  }
  
  if (count > 0) sumX / intToDouble(count) else -1.0
}

/**
 * Count alive minions for a team.
 * @param minions - List of minions
 * @param team - The team to count
 * @return Number of alive minions
 */
def countTeamAliveMinions(minions: List[Minion], team: Team): Int = {
  var count = 0
  listForEach(minions) { m =>
    if (m.isAlive) {
      val isMatch = team match {
        case Blue() => m.team match {
          case Blue() => true
          case Red() => false
        }
        case Red() => m.team match {
          case Blue() => false
          case Red() => true
        }
      }
      if (isMatch) {
        count = count + 1
      }
    }
  }
  count
}

/**
 * Calculate the current WaveState based on minion positions and counts.
 * @param minions - List of all minions
 * @param blueTurretX - X position of blue turret
 * @param redTurretX - X position of red turret
 * @return The calculated WaveState
 */
def calculateWaveState(minions: List[Minion], blueTurretX: Double, redTurretX: Double): WaveState = {
  val blueCount = countTeamAliveMinions(minions, Blue())
  val redCount = countTeamAliveMinions(minions, Red())
  
  if (blueCount == 0 && redCount == 0) {
    Neutral()
  } else {
    val blueAvgX = getTeamAverageX(minions, Blue())
    val redAvgX = getTeamAverageX(minions, Red())
    
    val laneCenter = (blueTurretX + redTurretX) / 2.0
    val blueZone = blueTurretX + 100.0
    val redZone = redTurretX - 100.0
    
    val countDiff = blueCount - redCount
    
    val wavePosition = if (blueAvgX >= 0.0 && redAvgX >= 0.0) {
      (blueAvgX + redAvgX) / 2.0
    } else {
      if (blueAvgX >= 0.0) blueAvgX else redAvgX
    }
    
    if (wavePosition < blueZone) {
      if (redCount > 0 && blueCount == 0) {
        Crashing()
      } else {
        if (countDiff > 2) {
          Bouncing()
        } else {
          FrozenBlue()
        }
      }
    } else {
      if (wavePosition > redZone) {
        if (blueCount > 0 && redCount == 0) {
          Crashing()
        } else {
          if (countDiff < -2) {
            Bouncing()
          } else {
            FrozenRed()
          }
        }
      } else {
        if (countDiff > 3) {
          PushingRed()
        } else {
          if (countDiff < -3) {
            PushingBlue()
          } else {
            if (countDiff > 1) {
              SlowPushRed()
            } else {
              if (countDiff < -1) {
                SlowPushBlue()
              } else {
                Neutral()
              }
            }
          }
        }
      }
    }
  }
}
