module src/handlers

import src/types
import src/utils/math
import src/utils/game
import src/tools/utils
import src/effects
import src/game/minion
import src/ffi/canvas
import src/ffi/events
import src/helpers


/**
 * Handles the State effect by maintaining a mutable variable.
 * @param initial The initial game state
 * @param prog The program to run
 * @return The result of the program
 */
def withState[R](initial: GameState) { prog: => R / State }: R = {
  var current = initial
  try { prog() } with State {
    def getState() = resume(current)
    def setState(s) = { current = s; resume(()) }
  }
}

/**
 * Handles the State effect for testing, returning the final state.
 * @param initial The initial game state
 * @param prog The program to run
 * @return A tuple of the result and the final state
 */
def withMockState[R](initial: GameState) { prog: => R / State }: (R, GameState) = {
  var current = initial
  val result = try { prog() } with State {
    def getState() = resume(current)
    def setState(s) = { current = s; resume(()) }
  }
  (result, current)
}

/**
 * Handles the Time effect.
 * @param initialTime The starting time
 * @param speed The simulation speed
 * @param prog The program to run
 * @return The result of the program
 */
def withTime[R](initialTime: Double, speed: SimulationSpeed) { prog: => R / Time }: R = {
  var time = initialTime
  val multiplier = speedMultiplier(speed)
  try { prog() } with Time {
    def getCurrentTime() = resume(time)
    def advanceTime(delta) = { time = time + (delta * multiplier); resume(()) }
    def getSpeedMultiplier() = resume(multiplier)
  }
}

/**
 * Handles the Input effect using actual browser events.
 * @param prog The program to run
 * @return The result of the program
 */
def withBrowserInput[R] { prog: => R / Input }: R = {
  try { prog() } with Input {
    def getMousePosition() = resume(Vec2(getMouseX(), getMouseY()))
    def wasClicked() = resume(wasMouseClicked())
    def isKeyDown(key) = resume(isKeyPressed(key))
    def wasKeyJustPressed(key) = resume(wasKeyJustPressed(key))
  }
}

/**
 * Handles the Input effect using mock data.
 * @param mousePos The simulated mouse position
 * @param clicked Whether the mouse is clicked
 * @param keys List of currently pressed keys
 * @param prog The program to run
 * @return The result of the program
 */
def withMockInput[R](mousePos: Vec2, clicked: Bool, keys: List[String]) { prog: => R / Input }: R = {
  try { prog() } with Input {
    def getMousePosition() = resume(mousePos)
    def wasClicked() = resume(clicked)
    def isKeyDown(key) = resume(listContainsString(keys, key))
    def wasKeyJustPressed(key) = resume(listContainsString(keys, key))
  }
}

/**
 * Handles the Render effect using HTML5 Canvas calls.
 * @param prog The program to run
 * @return The result of the program
 */
def withCanvasRenderer[R] { prog: => R / Render }: R = {
  try { prog() } with Render {
    def clear() = {
      clearCanvas()
      resume(())
    }
    
    def drawMinion(minion) = {
      if (minion.isAlive) {
        val x = minion.position.x
        val y = minion.position.y
        val radius = getMinionRadius(minion.minionType)
        
        minion.team match {
          case Blue() => 
            minion.minionType match {
              case Melee() => setFillColor(50, 120, 200, 1.0)
              case Caster() => setFillColor(80, 150, 230, 1.0)
              case Cannon() => setFillColor(30, 90, 170, 1.0)
            }
          case Red() =>
            minion.minionType match {
              case Melee() => setFillColor(200, 60, 60, 1.0)
              case Caster() => setFillColor(230, 90, 90, 1.0)
              case Cannon() => setFillColor(170, 40, 40, 1.0)
            }
        }
        
        fillCircle(x, y, radius)
        
        minion.minionType match {
          case Cannon() =>
            setStrokeColor(255, 215, 0, 0.8)
            setLineWidth(2.0)
            strokeCircle(x, y, radius)
          case _ => ()
        }
        
        val barWidth = radius * 2.0 + 4.0
        val barHeight = 3.0
        val barY = y - radius - 6.0
        val ratio = minion.currentHp / minion.stats.maxHp
        
        setFillColor(20, 20, 20, 0.8)
        fillRect(x - barWidth / 2.0, barY, barWidth, barHeight)
        
        if (ratio > 0.6) {
          setFillColor(60, 180, 60, 1.0)
        } else {
          if (ratio > 0.3) {
            setFillColor(220, 180, 40, 1.0)
          } else {
            setFillColor(200, 50, 50, 1.0)
          }
        }
        fillRect(x - barWidth / 2.0, barY, barWidth * ratio, barHeight)
      }
      
      resume(())
    }
    
    def drawTurret(turret) = {
      if (turret.isAlive) {
        val size = 35.0
        val x = turret.position.x
        val y = turret.position.y
        
        turret.team match {
          case Blue() => setStrokeColor(80, 150, 220, 0.3)
          case Red() => setStrokeColor(220, 100, 100, 0.3)
        }
        setLineWidth(2.0)
        strokeCircle(x, y, TURRET_STATS.attackRange)
        
        turret.team match {
          case Blue() => setFillColor(80, 150, 220, 0.08)
          case Red() => setFillColor(220, 100, 100, 0.08)
        }
        fillCircle(x, y, TURRET_STATS.attackRange)
        
        turret.team match {
          case Blue() => setFillColor(30, 100, 180, 1.0)
          case Red() => setFillColor(180, 50, 50, 1.0)
        }
        fillRect(x - size / 2.0, y - size / 2.0, size, size)
        
        turret.team match {
          case Blue() => setFillColor(50, 150, 220, 1.0)
          case Red() => setFillColor(220, 80, 80, 1.0)
        }
        fillRect(x - size / 4.0, y - size / 4.0, size / 2.0, size / 2.0)
        
        val barWidth = 40.0
        val barHeight = 4.0
        val barY = y - size / 2.0 - 10.0
        val ratio = turret.currentHp / TURRET_STATS.maxHp
        
        setFillColor(20, 20, 20, 0.8)
        fillRect(x - barWidth / 2.0 - 1.0, barY - 1.0, barWidth + 2.0, barHeight + 2.0)
        
        turret.team match {
          case Blue() => setFillColor(80, 150, 220, 1.0)
          case Red() => setFillColor(220, 80, 80, 1.0)
        }
        fillRect(x - barWidth / 2.0, barY, barWidth * ratio, barHeight)
      }
      
      resume(())
    }
    
    def drawHealthBar(pos, current, max, width) = {
      val height = 6.0
      val ratio = current / max
      
      setFillColor(40, 40, 40, 1.0)
      fillRect(pos.x - width / 2.0, pos.y, width, height)
      
      setFillColor(76, 175, 80, 1.0)
      fillRect(pos.x - width / 2.0, pos.y, width * ratio, height)
      
      resume(())
    }
    
    def drawLane() = {
      setFillColor(30, 35, 40, 1.0)
      fillRect(0.0, 0.0, CANVAS_WIDTH.toDouble, CANVAS_HEIGHT.toDouble)
      
      setFillColor(35, 50, 35, 1.0)
      fillRect(LANE_START_X, LANE_MIN_Y, LANE_END_X - LANE_START_X, LANE_HEIGHT)
      
      setFillColor(30, 50, 70, 0.6)
      fillRect(LANE_START_X, LANE_MIN_Y, BLUE_TURRET_X - LANE_START_X, LANE_HEIGHT)
      
      setFillColor(70, 40, 40, 0.6)
      fillRect(RED_TURRET_X, LANE_MIN_Y, LANE_END_X - RED_TURRET_X, LANE_HEIGHT)
      
      val innerPadding = 25.0
      setFillColor(55, 50, 40, 1.0)
      fillRect(BLUE_TURRET_X, LANE_MIN_Y + innerPadding, RED_TURRET_X - BLUE_TURRET_X, LANE_HEIGHT - innerPadding * 2.0)
      
      setStrokeColor(255, 255, 255, 0.12)
      setLineWidth(1.0)
      drawLine(LANE_START_X, LANE_Y, LANE_END_X, LANE_Y)
      
      setStrokeColor(100, 100, 200, 0.4)
      setLineWidth(2.0)
      drawLine(BLUE_TURRET_X, LANE_MIN_Y, BLUE_TURRET_X, LANE_MAX_Y)
      setStrokeColor(200, 100, 100, 0.4)
      drawLine(RED_TURRET_X, LANE_MIN_Y, RED_TURRET_X, LANE_MAX_Y)
      
      setStrokeColor(200, 100, 50, 0.7)
      setLineWidth(3.0)
      drawLine(LANE_START_X, LANE_MIN_Y, LANE_END_X, LANE_MIN_Y)
      drawLine(LANE_START_X, LANE_MAX_Y, LANE_END_X, LANE_MAX_Y)
      drawLine(LANE_START_X, LANE_MIN_Y, LANE_START_X, LANE_MAX_Y)
      drawLine(LANE_END_X, LANE_MIN_Y, LANE_END_X, LANE_MAX_Y)
      
      resume(())
    }
    
    def drawUI(state) = {
      setFont("bold 16px 'Cinzel', serif")
      setFillColor(200, 170, 100, 1.0)
      setTextAlign("left")
      
      val minutes = toInt(state.gameTime / 60.0)
      val seconds = modulo(toInt(state.gameTime), 60)
      val timeStr = "Time: " ++ show(minutes) ++ ":" ++ (if (seconds < 10) "0" else "") ++ show(seconds)
      fillText(timeStr, 20.0, 30.0)
      
      fillText("Wave: " ++ show(state.waveNumber), 20.0, 55.0)
      
      val blueCount = countTeamMinions(state.minions, Blue())
      val redCount = countTeamMinions(state.minions, Red())
      
      setFillColor(66, 165, 245, 1.0)
      fillText("Blue: " ++ show(blueCount), 20.0, 80.0)
      setFillColor(239, 83, 80, 1.0)
      fillText("Red: " ++ show(redCount), 90.0, 80.0)
      
      setTextAlign("right")
      setFillColor(200, 170, 100, 1.0)
      
      fillText("Speed: " ++ speedName(state.speed), intToDouble(CANVAS_WIDTH) - 20.0, 30.0)
      
      fillText("Tool: " ++ toolName(state.selectedTool), intToDouble(CANVAS_WIDTH) - 20.0, 55.0)
      
      state.waveState match {
        case Neutral() => setFillColor(200, 170, 100, 1.0)
        case PushingBlue() => setFillColor(239, 83, 80, 1.0)
        case PushingRed() => setFillColor(66, 165, 245, 1.0)
        case SlowPushBlue() => setFillColor(255, 150, 130, 1.0)
        case SlowPushRed() => setFillColor(130, 200, 255, 1.0)
        case FrozenBlue() => setFillColor(100, 200, 255, 0.9)
        case FrozenRed() => setFillColor(255, 180, 100, 0.9)
        case Crashing() => setFillColor(255, 80, 80, 1.0)
        case Bouncing() => setFillColor(80, 255, 150, 1.0)
      }
      setFont("bold 18px 'Cinzel', serif")
      fillText(waveStateName(state.waveState), intToDouble(CANVAS_WIDTH) - 20.0, 80.0)
      setFont("bold 16px 'Cinzel', serif")
      
      if (state.isPaused) {
        setFont("bold 32px 'Cinzel', serif")
        setTextAlign("center")
        setFillColor(200, 170, 100, 0.9)
        fillText("PAUSED", intToDouble(CANVAS_WIDTH) / 2.0, intToDouble(CANVAS_HEIGHT) / 2.0)
      }
      
      resume(())
    }
    
    def drawToolPreview(tool, mousePos) = {
      tool match {
        case AoETool() => {
          setStrokeColor(255, 200, 50, 0.6)
          setLineWidth(2.0)
          strokeCircle(mousePos.x, mousePos.y, AOE_RADIUS)
          setFillColor(255, 200, 50, 0.1)
          fillCircle(mousePos.x, mousePos.y, AOE_RADIUS)
        }
        case FullClearTool() => {
          setStrokeColor(255, 50, 50, 0.6)
          setLineWidth(2.0)
          strokeCircle(mousePos.x, mousePos.y, FULL_CLEAR_RANGE)
          setFillColor(255, 50, 50, 0.1)
          fillCircle(mousePos.x, mousePos.y, FULL_CLEAR_RANGE)
        }
        case TankTool() => {
          setFillColor(50, 255, 100, 0.3)
          fillCircle(mousePos.x, mousePos.y, 25.0)
          setStrokeColor(50, 255, 100, 0.8)
          setLineWidth(2.0)
          strokeCircle(mousePos.x, mousePos.y, 25.0)
        }
        case _ => ()
      }
      resume(())
    }
    
    def drawAttackLine(from, to, team) = {
      val centerX = to.x
      val centerY = to.y
      
      team match {
        case Blue() => setStrokeColor(200, 220, 255, 0.9)
        case Red() => setStrokeColor(255, 200, 200, 0.9)
      }
      setLineWidth(2.0)
      
      drawLine(centerX - 10.0, centerY - 10.0, centerX + 10.0, centerY + 10.0)
      drawLine(centerX - 8.0, centerY - 8.0, centerX + 8.0, centerY + 8.0)
      drawLine(centerX - 4.0, centerY + 4.0, centerX + 4.0, centerY - 4.0)
      
      team match {
        case Blue() => setFillColor(100, 180, 255, 0.5)
        case Red() => setFillColor(255, 100, 100, 0.5)
      }
      fillCircle(centerX, centerY, 15.0)
      
      resume(())
    }
    
    def drawMinionAttack(minion, target) = {
      val centerX = target.position.x
      val centerY = target.position.y
      
      minion.team match {
        case Blue() => setStrokeColor(200, 220, 255, 0.9)
        case Red() => setStrokeColor(255, 200, 200, 0.9)
      }
      setLineWidth(2.0)
      
      drawLine(centerX - 10.0, centerY - 10.0, centerX + 10.0, centerY + 10.0)
      drawLine(centerX - 8.0, centerY - 8.0, centerX + 8.0, centerY + 8.0)
      drawLine(centerX - 4.0, centerY + 4.0, centerX + 4.0, centerY - 4.0)
      
      minion.team match {
         case Blue() => setFillColor(100, 180, 255, 0.5)
         case Red() => setFillColor(255, 100, 100, 0.5)
      }
      fillCircle(centerX, centerY, 15.0)

      resume(())
    }
    
    def drawProjectile(p) = {
      if (p.isTurret) {
        setFillColor(255, 150, 50, 0.4)
        fillCircle(p.position.x, p.position.y, 14.0)
        setFillColor(255, 200, 50, 1.0)
        fillCircle(p.position.x, p.position.y, 8.0)
        setFillColor(255, 255, 200, 1.0)
        fillCircle(p.position.x, p.position.y, 4.0)
      } else if (p.isCaster) {
        setFillColor(255, 255, 200, 1.0)
        fillCircle(p.position.x, p.position.y, 4.0)
      } else {
        setFillColor(50, 50, 50, 1.0)
        fillCircle(p.position.x, p.position.y, 6.0)
      }
      resume(())
    }
    
    def drawVisualEffect(vfx, currentTime) = {
      val elapsed = currentTime - vfx.startTime
      val progress = elapsed / vfx.duration
      val alpha = maxDouble(0.0, 1.0 - progress)
      
      vfx.effectType match {
        case ClickRipple() =>
          val expandedRadius = vfx.radius * (1.0 + progress * 0.5)
          setStrokeColor(255, 255, 255, alpha * 0.6)
          setLineWidth(2.0)
          strokeCircle(vfx.position.x, vfx.position.y, expandedRadius)
          
        case AoeExplosion() =>
          val expandedRadius = vfx.radius * (0.8 + progress * 0.4)
          setStrokeColor(255, 180, 50, alpha * 0.8)
          setLineWidth(3.0)
          strokeCircle(vfx.position.x, vfx.position.y, expandedRadius)
          setFillColor(255, 200, 50, alpha * 0.2)
          fillCircle(vfx.position.x, vfx.position.y, expandedRadius)
          
        case LastHitMarker() =>
          setFillColor(255, 215, 0, alpha)
          val size = 8.0 * (1.0 - progress * 0.3)
          fillCircle(vfx.position.x, vfx.position.y - (progress * 15.0), size)
          setFont("bold 14px Arial")
          setTextAlign("center")
          fillText("+", vfx.position.x, vfx.position.y - 10.0 - (progress * 20.0))
          
        case KillMarker() =>
          setStrokeColor(255, 50, 50, alpha)
          setLineWidth(3.0)
          val size = 10.0 * (1.0 - progress * 0.2)
          drawLine(vfx.position.x - size, vfx.position.y - size, vfx.position.x + size, vfx.position.y + size)
          drawLine(vfx.position.x + size, vfx.position.y - size, vfx.position.x - size, vfx.position.y + size)
          
        case TankActivation() =>
          val expandedRadius = 25.0 * (1.0 + progress * 0.5)
          setStrokeColor(50, 255, 100, alpha * 0.8)
          setLineWidth(3.0)
          strokeCircle(vfx.position.x, vfx.position.y, expandedRadius)
          setFillColor(50, 255, 100, alpha * 0.15)
          fillCircle(vfx.position.x, vfx.position.y, expandedRadius)
      }
      resume(())
    }
    
    def drawTankIndicator(position, isTanking, gameTime) = {
      if (isTanking) {
        val x = position.x
        val y = position.y
        val aggroRange = 400.0
        
        val pulse = 0.8 + 0.2 * modDouble(gameTime * 3.0, 1.0)
        
        setStrokeColor(50, 255, 100, 0.3 * pulse)
        setLineWidth(2.0)
        strokeCircle(x, y, aggroRange)
        
        setFillColor(50, 255, 100, 0.15 * pulse)
        fillCircle(x, y, 35.0)
        
        setFillColor(30, 180, 80, 0.95)
        setStrokeColor(50, 255, 100, 1.0)
        setLineWidth(3.0)
        
        drawLine(x - 15.0, y - 18.0, x - 18.0, y - 5.0)
        drawLine(x - 18.0, y - 5.0, x - 12.0, y + 12.0)
        drawLine(x - 12.0, y + 12.0, x, y + 22.0)
        drawLine(x, y + 22.0, x + 12.0, y + 12.0)
        drawLine(x + 12.0, y + 12.0, x + 18.0, y - 5.0)
        drawLine(x + 18.0, y - 5.0, x + 15.0, y - 18.0)
        drawLine(x + 15.0, y - 18.0, x - 15.0, y - 18.0)
        
        setFillColor(40, 200, 100, 0.9)
        fillCircle(x, y, 12.0)
        
        setFillColor(255, 255, 255, 0.9)
        drawLine(x, y - 8.0, x + 6.0, y)
        drawLine(x + 6.0, y, x, y + 8.0)
        drawLine(x, y + 8.0, x - 6.0, y)
        drawLine(x - 6.0, y, x, y - 8.0)
        
        setFont("bold 12px Arial")
        setFillColor(50, 255, 100, 1.0)
        setTextAlign("center")
        fillText("TANKING", x, y - 35.0)
      }
      resume(())
    }
  }
}

/**
 * Handles the Render effect with no-op implementations for testing.
 * @param prog The program to run
 * @return The result of the program
 */
def withMockRenderer[R] { prog: => R / Render }: R = {
  try { prog() } with Render {
    def clear() = resume(())
    def drawMinion(_) = resume(())
    def drawTurret(_) = resume(())
    def drawHealthBar(_, _, _, _) = resume(())
    def drawLane() = resume(())
    def drawUI(_) = resume(())
    def drawToolPreview(_, _) = resume(())
    def drawAttackLine(_, _, _) = resume(())
    def drawMinionAttack(_, _) = resume(())
    def drawProjectile(_) = resume(())
    def drawVisualEffect(_, _) = resume(())
    def drawTankIndicator(_, _, _) = resume(())
  }
}