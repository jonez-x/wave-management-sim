module src/types

// ============================================================
// Wave Management Simulator - Core Data Types
// Phase 2: Type definitions for simulation entities
// ============================================================

// ============ POSITION & VECTORS ============

record Vec2(x: Double, y: Double)

def add(v1: Vec2, v2: Vec2): Vec2 =
  Vec2(v1.x + v2.x, v1.y + v2.y)

def sub(v1: Vec2, v2: Vec2): Vec2 =
  Vec2(v1.x - v2.x, v1.y - v2.y)

def scale(v: Vec2, s: Double): Vec2 =
  Vec2(v.x * s, v.y * s)

def magnitude(v: Vec2): Double = {
  val sq = v.x * v.x + v.y * v.y
  sqrt(sq)
}

def normalize(v: Vec2): Vec2 = {
  val mag = magnitude(v)
  if (mag > 0.0) Vec2(v.x / mag, v.y / mag)
  else Vec2(0.0, 0.0)
}

def distance(p1: Vec2, p2: Vec2): Double =
  magnitude(sub(p2, p1))

// Square root approximation using Newton's method
def sqrt(x: Double): Double = {
  if (x <= 0.0) 0.0
  else {
    // Newton's method for square root
    def iterate(guess: Double, n: Int): Double = {
      if (n <= 0) guess
      else {
        val better = (guess + x / guess) / 2.0
        iterate(better, n - 1)
      }
    }
    iterate(x / 2.0, 10)
  }
}

// ============ TEAM ============

type Team {
  Blue()
  Red()
}

def opposite(team: Team): Team =
  team match {
    case Blue() => Red()
    case Red() => Blue()
  }

def teamName(team: Team): String =
  team match {
    case Blue() => "Blue"
    case Red() => "Red"
  }

// ============ MINION TYPES ============

type MinionType {
  Melee()
  Caster()
  Cannon()
}

def minionTypeName(minionType: MinionType): String =
  minionType match {
    case Melee() => "Melee"
    case Caster() => "Caster"
    case Cannon() => "Cannon"
  }

// ============ MINION STATS (League-accurate) ============

record MinionStats(
  maxHp: Double,
  attackDamage: Double,
  attackSpeed: Double,      // attacks per second
  attackRange: Double,      // pixels
  movementSpeed: Double,    // pixels per second
  goldValue: Int
)

// Scale factor: LoL Units -> Simulation Pixels
// LoL Minion Radius ~ 48 units. Sim Radius ~ 12 pixels.
// Ratio = 12 / 48 = 0.25.
val STAT_SCALE: Double = 0.25

// Damage Scale: Slower combat for wave stacking
val DAMAGE_SCALE: Double = 0.6

def getMinionStats(minionType: MinionType): MinionStats =
  minionType match {
    case Melee() => MinionStats(
      maxHp = 477.0,
      attackDamage = 12.0 * DAMAGE_SCALE,
      attackSpeed = 1.25,
      attackRange = 110.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 21
    )
    case Caster() => MinionStats(
      maxHp = 296.0,
      attackDamage = 24.0 * DAMAGE_SCALE,
      attackSpeed = 0.667,
      attackRange = 550.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 14
    )
    case Cannon() => MinionStats(
      maxHp = 912.0,
      attackDamage = 41.0 * DAMAGE_SCALE,
      attackSpeed = 1.0,
      attackRange = 300.0 * STAT_SCALE,
      movementSpeed = 325.0 * STAT_SCALE,
      goldValue = 60
    )
  }

// Get minion radius for rendering
def getMinionRadius(minionType: MinionType): Double =
  minionType match {
    case Melee() => 12.0
    case Caster() => 8.0
    case Cannon() => 18.0
  }

// ============ MINION ============

record Minion(
  id: Int,
  team: Team,
  minionType: MinionType,
  position: Vec2,
  currentHp: Double,
  stats: MinionStats,
  targetId: Int,            // -1 means no target
  lastAttackTime: Double,
  isAlive: Bool
)

// Apply scaling based on game time (90s cycles)
def applyScaling(stats: MinionStats, minionType: MinionType, gameTime: Double): MinionStats = {
  // Cycle starts after first wave spawn (approx 90s interval)
  // Let's assume cycle 0 starts at 0:00 for simplicity or align with wave spawns
  // Formula: Cycles = floor((t - StartTime) / 90)
  val cycleDuration = 90.0
  val cycles = floorDouble(maxDouble(0.0, gameTime) / cycleDuration)
  
  if (cycles <= 0.0) {
    stats
  } else {
    // Scaling coefficients
    val (hpGrowth, adGrowth) = minionType match {
      case Melee() => (20.0, 0.5) // +20 HP, +0.5 AD
      case Caster() => (15.0, 2.0) // +15 HP, +2.0 AD
      case Cannon() => (50.0, 3.0) // +50 HP, +3.0 AD
    }
    
    // Calculate bonuses
    val bonusHp = hpGrowth * cycles
    val bonusAd = adGrowth * cycles
    
    MinionStats(
      maxHp = stats.maxHp + bonusHp,
      attackDamage = stats.attackDamage + bonusAd,
      attackSpeed = stats.attackSpeed,
      attackRange = stats.attackRange,
      movementSpeed = stats.movementSpeed, // Speed scaling handled separately if needed
      goldValue = stats.goldValue
    )
  }
}

def createMinion(id: Int, team: Team, minionType: MinionType, spawnPos: Vec2, gameTime: Double): Minion = {
  val baseStats = getMinionStats(minionType)
  val scaledStats = applyScaling(baseStats, minionType, gameTime)
  
  Minion(
    id = id,
    team = team,
    minionType = minionType,
    position = spawnPos,
    currentHp = scaledStats.maxHp,
    stats = scaledStats,
    targetId = -1,
    lastAttackTime = 0.0,
    isAlive = true
  )
}

def hasTarget(minion: Minion): Bool =
  minion.targetId >= 0

// ============ TURRET ============

record TurretStats(
  maxHp: Double,
  attackDamage: Double,
  attackSpeed: Double,
  attackRange: Double
)

val TURRET_STATS: TurretStats = TurretStats(
  maxHp = 5000.0,
  attackDamage = 152.0 * DAMAGE_SCALE,
  attackSpeed = 0.83,
  attackRange = 750.0 * STAT_SCALE
)

record Turret(
  id: Int,
  team: Team,
  position: Vec2,
  currentHp: Double,
  targetId: Int,            // -1 means no target
  lastAttackTime: Double,
  isAlive: Bool
)

def createTurret(id: Int, team: Team, pos: Vec2): Turret =
  Turret(
    id = id,
    team = team,
    position = pos,
    currentHp = TURRET_STATS.maxHp,
    targetId = -1,
    lastAttackTime = 0.0,
    isAlive = true
  )

// ============ TOOL TYPES ============

type Tool {
  LastHitTool()
  AoETool()
  KillCastersTool()
  FullClearTool()
  TankTool()
  NoTool()
}

def toolName(tool: Tool): String =
  tool match {
    case LastHitTool() => "Last Hit"
    case AoETool() => "AoE Damage"
    case KillCastersTool() => "Kill Casters"
    case FullClearTool() => "Full Clear"
    case TankTool() => "Tank"
    case NoTool() => "None"
  }

// Tool parameters
val AOE_RADIUS: Double = 80.0
val AOE_DAMAGE: Double = 150.0
val FULL_CLEAR_RANGE: Double = 200.0
val LASTHIT_THRESHOLD: Double = 50.0

// ============ PROJECTILES ============

record Projectile(
  id: Int,
  position: Vec2,
  targetId: Int,
  damage: Double,
  speed: Double,
  isCaster: Bool,    // true = Caster (small), false = Cannon (large)
  targetPos: Vec2    // Snapshot of target position (for validation or non-homing)
)

// ============ SIMULATION STATE ============

type SimulationSpeed {
  Speed1x()
  Speed2x()
  Speed4x()
}

def speedMultiplier(speed: SimulationSpeed): Double =
  speed match {
    case Speed1x() => 1.0
    case Speed2x() => 2.0
    case Speed4x() => 4.0
  }

def speedName(speed: SimulationSpeed): String =
  speed match {
    case Speed1x() => "1x"
    case Speed2x() => "2x"
    case Speed4x() => "4x"
  }

// ============ WAVE STATE DETECTION ============

type WaveState {
  Neutral()
  PushingBlue()
  PushingRed()
  SlowPushBlue()
  SlowPushRed()
  FrozenBlue()
  FrozenRed()
  Crashing()
  Bouncing()
}

def waveStateName(state: WaveState): String =
  state match {
    case Neutral() => "Neutral"
    case PushingBlue() => "Pushing Blue"
    case PushingRed() => "Pushing Red"
    case SlowPushBlue() => "Slow Push Blue"
    case SlowPushRed() => "Slow Push Red"
    case FrozenBlue() => "Frozen (Blue Side)"
    case FrozenRed() => "Frozen (Red Side)"
    case Crashing() => "Crashing"
    case Bouncing() => "Bouncing"
  }

// ============ GAME STATE ============

record PendingSpawn(
  team: Team,
  minionType: MinionType,
  spawnTime: Double,
  laneOffset: Double // Use this to vary the path slightly if needed
)

// ============ GAME STATE ============

record GameState(
  minions: List[Minion],
  blueTurret: Turret,
  redTurret: Turret,
  gameTime: Double,
  waveNumber: Int,
  nextSpawnTime: Double,
  isPaused: Bool,
  speed: SimulationSpeed,
  selectedTool: Tool,
  nextEntityId: Int,
  waveState: WaveState,
  isPlayerTanking: Bool,
  tankPosition: Vec2,
  projectiles: List[Projectile],
  pendingSpawns: List[PendingSpawn]
)

// ============ CONSTANTS ============

// Canvas dimensions
val CANVAS_WIDTH: Int = 1200
val CANVAS_HEIGHT: Int = 400

// Lane layout
val LANE_Y: Double = 200.0
val LANE_START_X: Double = 100.0
val LANE_END_X: Double = 1100.0

// Spawn positions
val BLUE_SPAWN_X: Double = 150.0
val RED_SPAWN_X: Double = 1050.0

// Wave spawning
val SPAWN_INTERVAL: Double = 30.0
val CANNON_WAVE_INTERVAL: Int = 3

// Turret positions
val BLUE_TURRET_X: Double = 100.0
val RED_TURRET_X: Double = 1100.0

// ============ INITIAL STATE ============

def createInitialState(): GameState = {
  val blueTurret = createTurret(0, Blue(), Vec2(BLUE_TURRET_X, LANE_Y))
  val redTurret = createTurret(1, Red(), Vec2(RED_TURRET_X, LANE_Y))
  
  GameState(
    minions = Nil(),
    blueTurret = blueTurret,
    redTurret = redTurret,
    gameTime = 0.0,
    waveNumber = 0,
    nextSpawnTime = 0.0, // Start immediately as requested
    isPaused = false,
    speed = Speed1x(),
    selectedTool = NoTool(),
    nextEntityId = 2,
    waveState = Neutral(),
    isPlayerTanking = false,
    tankPosition = Vec2(0.0, 0.0),
    projectiles = Nil(),
    pendingSpawns = Nil()
  )
}

// ============ HELPER FUNCTIONS ============

// List helpers
def listLength[A](list: List[A]): Int =
  list match {
    case Nil() => 0
    case Cons(_, rest) => 1 + listLength(rest)
  }

def listFilter[A](list: List[A]) { pred: A => Bool }: List[A] =
  list match {
    case Nil() => Nil()
    case Cons(x, rest) =>
      if (pred(x)) Cons(x, listFilter(rest) { a => pred(a) })
      else listFilter(rest) { a => pred(a) }
  }

def listMap[A, B](list: List[A]) { f: A => B }: List[B] =
  list match {
    case Nil() => Nil()
    case Cons(x, rest) => Cons(f(x), listMap(rest) { a => f(a) })
  }

def listForEach[A](list: List[A]) { f: A => Unit }: Unit =
  list match {
    case Nil() => ()
    case Cons(x, rest) =>
      f(x)
      listForEach(rest) { a => f(a) }
  }

def listFind[A](list: List[A]) { pred: A => Bool }: Option[A] =
  list match {
    case Nil() => None()
    case Cons(x, rest) =>
      if (pred(x)) Some(x)
      else listFind(rest) { a => pred(a) }
  }

def listAppend[A](list1: List[A], list2: List[A]): List[A] =
  list1 match {
    case Nil() => list2
    case Cons(x, rest) => Cons(x, listAppend(rest, list2))
  }

// Math helpers
def maxDouble(a: Double, b: Double): Double =
  if (a > b) a else b

def minDouble(a: Double, b: Double): Double =
  if (a < b) a else b

def clamp(value: Double, minVal: Double, maxVal: Double): Double =
  maxDouble(minVal, minDouble(value, maxVal))

def absDouble(x: Double): Double =
  if (x < 0.0) 0.0 - x else x

// Floor function
def floorDouble(x: Double): Double = {
  val i = x.toInt
  if (x < 0.0 && x != i.toDouble) (i - 1).toDouble
  else i.toDouble
}

// Modulo for doubles
def modDouble(x: Double, y: Double): Double =
  x - (floorDouble(x / y) * y)
